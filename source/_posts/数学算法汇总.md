---
title: 数学算法汇总
mathjax: true
date: 2022-07-12 16:02:23
tags:
- 数学
categories:
- 算法
- 数学
---

## 数学算法介绍

主要介绍一些数学相关的算法。

### 多项式

#### FFT 多项式乘法

~~最开始学这玩意的时候感觉非常迷，后面数学水平上去了其实也不难。~~

多项式有两种表示方法，一种是系数法，另一种是点值法，总所周知 $n$ 个不同点唯一确定一个 $n-1$ 次多项式。

原理：多项式的两个系数表达式相乘是 $O(n^2)$ 的，但是其点值表达式相乘却是  $O(n)$ 的，所以考虑将系数表达式转成点值表达式然后相乘。

事实上，点值表达式和系数表达式的互相转化，如果点值取特殊点，可以做到 $O(n\log n)$，即使是任意点，即多项式多点求值和多项式多点插值也可以做到 $O(n \log^2n)$

设最终多项式次数为 $n-1$，我们进行多项式乘法时选择的点值叫单位根，即 $x^n=1$ 在复数域上的所有根。

这玩意有一些性质，不过我们得先把次数变为 $n=2^k$ 形式。

无法想象发明这个东西的人是怎么想到的，可能这就是被记在历史书上的人的水平。

*以下内容如果将坐标系视为极坐标系会更好理解*
$$
W_n^i = -W_n^{i+\frac{n}{2}}\\
W_{\frac{n}{2}}^{i} = W_{n}^{2i}\\
$$
考虑这样一个问题，对于一个多项式 $a_0+a_1x+a_2x^2 \cdots a_{n-1}x^{n-1}$ ，我们需要同时求出它在 $W_n^{0},W_n^{1}\cdots W_n^{n-1}$ 处的取值。发现由于第一个性质，貌似可以偷个懒，因为后 $\frac{n}{2}$ 个数就是前 $\frac{n}{2}$ 个数的相反数。

相反数的性质，奇变偶不变。考虑对系数按奇偶性分类，式子变成了这个样子。

$(a_0+a_2x^2+\cdots +a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots + a_{n-1}x^{n-2})$

然后考虑前后两个部分，需要对他们求 $x=W_n^0,W_n^1\cdots W_n^{\frac{n}{2}-1}$ 处的取值，本质上是求 $x^2=W_n^0,W_n^2\cdots W_n^{n-2}$ 处的取值，结合第二个性质，woc，就是两个子问题，解决之后就可以 $O(n)$ 得到原问题的解，边界显然是 $n=1$。

复杂度 $T(n)=2T(\frac{n}{2}) + O(n) = O(n\log n)$

```c++
void FFT(int now,com *a,int op)
{
	if(now==0)
	return;
	com a1[1<<now],a2[1<<now];
	for(i=0;i<1<<now;i+=2)
	{
		a1[i/2]=a[i];
		a2[i/2]=a[i+1];
	}
	FFT(now-1,a1,op);
	FFT(now-1,a2,op);
	com w0=(com{cos(2.0*Pi/(1<<now)),op*sin(2.0*Pi/(1<<now))}),w=(com){1,0};
	for(i=0;i<1<<now-1;i++,w=w*w0)
	{
		a[i]=a1[i]+w*a2[i];
		a[i+(1<<(now-1))]=a1[i]-w*a2[i];
	}
}
```

但是如果递归的话，常数会比较拉跨。因为递归必然需要复制数组重新弄成一个下标 $1-n$ 的问题，无论用什么办法解决，你的高速缓存都会表示意见很大，所以考虑迭代写法。

本质上递归是一层一层合并了两个数组，那么能不能直接模拟这个合并的过程呢，答案是可以的。

观察发现本质上是将下标二进制 `reverse` 之后逐层合并的，我们也这么做就行。

求 `reverse` 可以 $O(n)$，如下（如果你不了解运算顺序，请老老实实打括号）

这个原理很简单，不看最后一位，其它位先 `reverse`，然后处理一下最后一位就行。

```cpp
for(int i=1;i<1<<lim;i++)res[i]=res[i>>1]>>1|(i&1)<<1-lim;
```

下面是迭代写法代码，本质是模拟了递归合并的过程。

```cpp
void FFT(com a[],com b[],int op)
{
	for(i=0;i<1<<maxn;i++)
    if(r[i]>i)swap(a[r[i]],a[i]),swap(b[r[i]],b[i]);
	for(i=1;i<=maxn;i++){
		for(j=0;j<1<<maxn;j+=1<<i){
			com w0=(com){cos(2.0*Pi/(1<<i)),op*sin(2.0*Pi/(1<<i))},w=(com){1,0};
			for(k=0;k<1<<i-1;k++,w=w*w0){
				com x=a[j+k],y=a[j+k+(1<<i-1)]*w;
				a[j+k]=x+y;
				a[j+k+(1<<i-1)]=x-y;
                
				x=b[j+k],y=b[j+k+(1<<i-1)]*w;
				b[j+k]=x+y;
				b[j+k+(1<<i-1)]=x-y;
			}
		}
	}
}
```

搞完了系数转点值，接下来是点值转系数。

前人告诉我们只需要将单位根改为 $W_n^{0},W_n^{-1}\cdots W_n^{-n+1}$，再做一遍系数转点值的过程就可以得到系数，但是系数会变成原来的 $n$ 倍，除掉就行。

给出简要证明，$i$ 次项的系数为 $a_i$，转一次点值

之后变为 $b_i$，再做一次变成 $c_i$
$$
\begin{eqnarray}
c_x &=& \sum\limits_{i=0}^{n-1}b_iW_n^{-ix} \\
 &=& \sum\limits_{i=0}^{n-1} W_n^{-ix}\sum\limits_{j=0}^{n-1}a_jW_n^{ij}\\
 &=& \sum\limits_{i=0}^{n-1} \sum\limits_{j=0}^{n-1}a_jW_n^{i(j-x)}\\
\end{eqnarray}
$$
对于 $j=x$，贡献显然为 $\sum\limits_{i=0}^{n-1}a_xW_n^{i\times0} = na_x$

对于 $j\neq x$ 贡献为 $a_j \sum\limits_{i=0}^{n-1}(W_n^{j-x})^{i}$

对这个式子的求和用等比数列求和公式有贡献为 $\dfrac{W_n^{n(j-x)}-1}{W_n^{j-x}-1}$

显然分子为 $0$，分母不为 $0$，所以贡献是 $0$，所以结果就是 $na_x$

搞定。

#### NTT 多项式乘法

FFT 多项式乘法是由缺陷的，由于浮点数精度和运算速度问题，FFT 可能并不能很好的解决一些问题，所以引入了 NTT，NTT 从有限整数域中找到了这样一组具有同样优秀性质的 $W_n$，即 $g$，也就是原根。

原根的内容可以参考数学证明总结中的介绍。

**注意，和 FFT 一样，NTT 也需要严格的按照 $2^k$ 取次数，因为我们利用了 $W_n^{2i} = W_{\frac{n}{2}}^{i}$ 这一重要性质** 

所以能取出较大的 $2^k$ 作为阶的质数才可以作为 NTT 的模数，常见的 NTT 模数是 $998244353=2^{23}\times 7\times 17 +1$ ，我们可以取它的原根 $g=3$ 作为基本单位根带入，实际上如果要找到一个应用于 $n$ 的单位根 $W_n$，需要取 $W_n=g^{\frac{p-1}{n}}$。这样它就满足了我们在 FFT 证明中用到的一切性质。

然后照着 FFT 打一遍就行，只是基本运算这些换为模 $p$ 意义下的运算就行。

```cpp
void NTT(int *a,int type)
{
	for(i=0;i<1<<s;i++)
	if(rk[i]>i)swap(a[rk[i]],a[i]);
	for(int len=1;len<=s;len++)
	{
		int w=1,wn=quick(g,mod-1>>len);
		if(type==-1)wn=quick(wn,mod-2);
		for(j=0;j+(1<<len)<=1<<s;j+=1<<len,w=1)
		{
			for(k=j;k<j+(1<<len-1);k++,w=1ll*w*wn%mod)
			{
				int x=a[k],y=a[k+(1<<len-1)];
				a[k]=(x+1ll*w*y%mod)%mod,a[k+(1<<len-1)]=(x-1ll*w*y%mod)%mod;
			}
		}
	}
}
```

#### 其它多项式乘法和一些优化

FFT 三次变两次，把 $b$ 扔到 $a$ 的虚部去，变成了 $A(x) = (a_0+b_0i) + (a_1+b_1i)x+ \cdots + (a_{n-1}+b_{n-1}i)x^{n-1}$

然后求 $A^2(x)$，得到的系数表达式的虚部就是 $2ab$。

会比 NTT 略快。





